import logging
import copy
import re

from ckan.common import OrderedDict

log = logging.getLogger(__name__)

REPORT_KEYS_REQUIRED = set(('name', 'generate', 'template', 'option_defaults',
                            'option_combinations'))
REPORT_KEYS_OPTIONAL = set(('title',))


class Report(object):
    '''Represents a report that can be generated. Instances are generated by
    ReportCacheRegistry.'''
    def __init__(self, report_info_dict, plugin):
        # Check the report_info_dict has the correct keys
        missing_required_keys = REPORT_KEYS_REQUIRED - set(report_info_dict.keys())
        assert not missing_required_keys, 'Report info dict missing keys %r: '\
            '%r' % (missing_required_keys, report_info_dict)
        unknown_keys = set(report_info_dict.keys()) - REPORT_KEYS_REQUIRED - \
                       REPORT_KEYS_OPTIONAL
        assert not unknown_keys, 'Report info dict has unrecognized keys %r: '\
            '%r' % (unknown_keys, report_info_dict)
        assert isinstance(report_info_dict['option_defaults'], OrderedDict)
        for key in report_info_dict:
            setattr(self, key, report_info_dict[key])
        self.plugin = plugin
        if not hasattr(self, 'title'):
            self.title = re.sub('[_-]', ' ', self.name.capitalize())

    def generate_key(self, option_dict, defaults_for_missing_keys=True):
        '''Returns a key that will identify the report and options when saved
        in the DataCache. It looks like URL parameters for convenience.'''
        options_serialized = []
        for key in self.option_defaults:
            if defaults_for_missing_keys:
                value = option_dict.get(key,
                                        self.option_defaults[key])
            else:
                value = option_dict[key]
            if isinstance(value, basestring):
                value = str(value)
            elif isinstance(value, bool):
                value = 1 if value else 0
            else:
                value = repr(value)
            option = '%s=%s' % (key, value)
            options_serialized.append(option)
        if options_serialized:
            return '%s?%s' % (self.name, '&'.join(options_serialized))
        else:
            return '%s' % self.name

    def refresh_cache_for_all_options(self):
        '''Generates the report for all the option combinations and caches them.'''
        log.info('Report: %s %s', self.plugin, self.name)
        option_combinations = list(self.option_combinations()) \
                              if self.option_combinations else [{}]
        for option_dict in option_combinations:
            self.refresh_cache(option_dict)
        log.info('  report done')

    def refresh_cache(self, option_dict):
        '''Generates a report for the given options and caches it.

        Returns (data, date)
        '''
        from ckan import model
        log.info('  options: %r', option_dict)
        data = self.generate(**option_dict)
        # option_combinations should specify every key, so mustn't allow
        # default values
        key = self.generate_key(option_dict, defaults_for_missing_keys=False)
        date = model.DataCache.set(extract_entity_name(option_dict),
                                   key, data, convert_json=True)
        model.Session.commit()
        return data, date

    def get_fresh_report(self, **option_dict):
        from ckan import model
        entity_name = extract_entity_name(option_dict)
        key = self.generate_key(option_dict)
        data, date = model.DataCache.get_if_fresh(entity_name, key,
                                                  convert_json=True)
        if data is None:
            data, date = self.refresh_cache(option_dict)
        return data, date

    def get_cached_date(self, **option_dict):
        from ckan import model
        if not option_dict:
            option_dict = self.option_defaults
        entity_name = extract_entity_name(option_dict)
        key = self.generate_key(option_dict)
        data, date = model.DataCache.get(entity_name, key)
        return date

    def get_template(self):
        return self.template

    def add_defaults_to_options(self, options):
        defaulted_options = copy.deepcopy(self.option_defaults)
        defaulted_options.update(options)
        return defaulted_options


def extract_entity_name(option_dict):
    '''Hunts for an option key that is the entity name and returns its
    value. Used in the DataCache storage.'''
    for entity_name in ('organization', 'publisher', 'group', 'package', 'resource'):
        if entity_name in option_dict:
            return option_dict[entity_name]
    return None


class ReportCacheRegistry(object):
    _instance = None
    _reports = {}  # name: report

    @classmethod
    def instance(cls):
        if not cls._instance:
            cls._instance = cls()
        return cls._instance

    def __init__(self):
        # register all the reports
        import ckan.plugins as p
        self._reports = {}  # this reset is needed for 'paster serve --restart'
        for plugin in p.PluginImplementations(p.IReportCache):
            report_info_dicts = plugin.register_reports()
            for report_info_dict in report_info_dicts:
                assert report_info_dict['name'] not in self._reports, \
                    'Duplicate report name %s' % report_info_dict['name']
                plugin_name = '%s (%s)' % (plugin.__class__.__name__,
                                           plugin.name)
                self._reports[report_info_dict['name']] = \
                    Report(report_info_dict, plugin_name)

    def get_names(self):
        return [(r.plugin, r.name, r.title)
                for r in sorted(self._reports.values(), key=lambda r: r.plugin)]

    def get_report(self, report_name):
        return self._reports[report_name]

    def refresh_cache_for_all_reports(self):
        '''Generates all the reports for all the option combinations and caches them.'''
        for report in self._reports.values():
            report.refresh_cache_for_all_options()


#    'name': 'feedback-report',
#    'option_combinations': nii_report_combinations,
#    'generate': nii_report,
